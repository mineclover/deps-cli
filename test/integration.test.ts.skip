/**
 * ÌÜµÌï© ÌÖåÏä§Ìä∏ - Ïã§Ï†ú ÌîÑÎ°úÏ†ùÌä∏ ÏãúÎÇòÎ¶¨Ïò§
 */

import { describe, test, expect, beforeAll, afterAll, beforeEach } from "vitest"
import { execSync } from "node:child_process"
import * as fs from "node:fs/promises"
import * as path from "node:path"
import { fileURLToPath } from "node:url"

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const PROJECT_ROOT = path.resolve(__dirname, "..")
const CLI_PATH = path.join(PROJECT_ROOT, "dist", "bin.js")
const TEST_FIXTURES_DIR = path.join(__dirname, "fixtures", "integration-tests")

// Í∏¥ ÌÖåÏä§Ìä∏Î•º ÏúÑÌïú ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
const LONG_TIMEOUT = 60000

describe("ÌÜµÌï© ÌÖåÏä§Ìä∏ - Ïã§Ï†ú ÌîÑÎ°úÏ†ùÌä∏ ÏãúÎÇòÎ¶¨Ïò§", () => {
  beforeAll(async () => {
    await fs.mkdir(TEST_FIXTURES_DIR, { recursive: true })
  })

  afterAll(async () => {
    await fs.rm(TEST_FIXTURES_DIR, { recursive: true, force: true })
  })

  beforeEach(async () => {
    await fs.rm(TEST_FIXTURES_DIR, { recursive: true, force: true })
    await fs.mkdir(TEST_FIXTURES_DIR, { recursive: true })
  })

  describe("React ÌîÑÎ°úÏ†ùÌä∏ ÏãúÎÇòÎ¶¨Ïò§", () => {
    test("Ï†ÑÌòïÏ†ÅÏù∏ React ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Î∂ÑÏÑù", async () => {
      // React ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ ÏÉùÏÑ±
      const projectDir = path.join(TEST_FIXTURES_DIR, "react-project")
      const srcDir = path.join(projectDir, "src")
      const componentsDir = path.join(srcDir, "components")
      const hooksDir = path.join(srcDir, "hooks")
      const utilsDir = path.join(srcDir, "utils")
      const testsDir = path.join(projectDir, "__tests__")

      await fs.mkdir(componentsDir, { recursive: true })
      await fs.mkdir(hooksDir, { recursive: true })
      await fs.mkdir(utilsDir, { recursive: true })
      await fs.mkdir(testsDir, { recursive: true })

      // package.json
      await fs.writeFile(path.join(projectDir, "package.json"), `
{
  "name": "react-test-project",
  "version": "1.0.0",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "axios": "^1.4.0",
    "react-router-dom": "^6.8.0"
  },
  "devDependencies": {
    "@types/react": "^18.0.0",
    "@testing-library/react": "^13.0.0",
    "typescript": "^4.9.0",
    "vite": "^4.0.0"
  }
}
      `)

      // tsconfig.json
      await fs.writeFile(path.join(projectDir, "tsconfig.json"), `
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@hooks/*": ["src/hooks/*"],
      "@utils/*": ["src/utils/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
      `)

      // Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò
      await fs.writeFile(path.join(utilsDir, "api.ts"), `
import axios, { AxiosResponse } from "axios"

export interface ApiResponse<T> {
  data: T
  status: number
  message: string
}

export class ApiClient {
  private baseURL: string

  constructor(baseURL: string) {
    this.baseURL = baseURL
  }

  async get<T>(endpoint: string): Promise<ApiResponse<T>> {
    try {
      const response: AxiosResponse<T> = await axios.get(\`\${this.baseURL}\${endpoint}\`)
      return {
        data: response.data,
        status: response.status,
        message: "Success"
      }
    } catch (error) {
      throw new Error(\`API Error: \${error}\`)
    }
  }

  async post<T>(endpoint: string, data: any): Promise<ApiResponse<T>> {
    const response: AxiosResponse<T> = await axios.post(\`\${this.baseURL}\${endpoint}\`, data)
    return {
      data: response.data,
      status: response.status,
      message: "Success"
    }
  }
}

export const apiClient = new ApiClient(process.env.REACT_APP_API_URL || "http://localhost:3000")
      `)

      await fs.writeFile(path.join(utilsDir, "helpers.ts"), `
export function formatDate(date: Date): string {
  return date.toLocaleDateString("ko-KR", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  })
}

export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null

  return (...args: Parameters<T>) => {
    if (timeout) {
      clearTimeout(timeout)
    }
    timeout = setTimeout(() => func(...args), wait)
  }
}

export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args)
      inThrottle = true
      setTimeout(() => (inThrottle = false), limit)
    }
  }
}
      `)

      // React ÌõÖÎì§
      await fs.writeFile(path.join(hooksDir, "useApi.ts"), `
import { useState, useEffect } from "react"
import { apiClient, ApiResponse } from "@utils/api"

export function useApi<T>(endpoint: string) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true)
        const response: ApiResponse<T> = await apiClient.get<T>(endpoint)
        setData(response.data)
        setError(null)
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error")
        setData(null)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [endpoint])

  return { data, loading, error }
}
      `)

      await fs.writeFile(path.join(hooksDir, "useLocalStorage.ts"), `
import { useState, useEffect } from "react"

export function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(\`Error reading localStorage key "\${key}":\`, error)
      return initialValue
    }
  })

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value
      setStoredValue(valueToStore)
      window.localStorage.setItem(key, JSON.stringify(valueToStore))
    } catch (error) {
      console.error(\`Error setting localStorage key "\${key}":\`, error)
    }
  }

  return [storedValue, setValue] as const
}
      `)

      // React Ïª¥Ìè¨ÎÑåÌä∏Îì§
      await fs.writeFile(path.join(componentsDir, "Button.tsx"), `
import React from "react"

export interface ButtonProps {
  children: React.ReactNode
  onClick?: () => void
  disabled?: boolean
  variant?: "primary" | "secondary" | "danger"
  size?: "small" | "medium" | "large"
}

export function Button({
  children,
  onClick,
  disabled = false,
  variant = "primary",
  size = "medium"
}: ButtonProps) {
  const baseClasses = "px-4 py-2 rounded font-medium focus:outline-none focus:ring-2"

  const variantClasses = {
    primary: "bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500",
    secondary: "bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500",
    danger: "bg-red-600 text-white hover:bg-red-700 focus:ring-red-500"
  }

  const sizeClasses = {
    small: "px-2 py-1 text-sm",
    medium: "px-4 py-2",
    large: "px-6 py-3 text-lg"
  }

  const className = \`\${baseClasses} \${variantClasses[variant]} \${sizeClasses[size]} \${
    disabled ? "opacity-50 cursor-not-allowed" : ""
  }\`

  return (
    <button
      className={className}
      onClick={onClick}
      disabled={disabled}
      type="button"
    >
      {children}
    </button>
  )
}
      `)

      await fs.writeFile(path.join(componentsDir, "UserList.tsx"), `
import React from "react"
import { useApi } from "@hooks/useApi"
import { Button } from "./Button"
import { formatDate } from "@utils/helpers"

export interface User {
  id: number
  name: string
  email: string
  createdAt: string
}

export function UserList() {
  const { data: users, loading, error } = useApi<User[]>("/users")

  if (loading) {
    return <div className="text-center">Loading users...</div>
  }

  if (error) {
    return <div className="text-red-600">Error: {error}</div>
  }

  if (!users || users.length === 0) {
    return <div className="text-gray-500">No users found</div>
  }

  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">Users</h2>
      <div className="grid gap-4">
        {users.map((user) => (
          <div key={user.id} className="border rounded-lg p-4">
            <h3 className="font-semibold">{user.name}</h3>
            <p className="text-gray-600">{user.email}</p>
            <p className="text-sm text-gray-500">
              Joined: {formatDate(new Date(user.createdAt))}
            </p>
            <div className="mt-2 space-x-2">
              <Button size="small" onClick={() => console.log(\`Edit user \${user.id}\`)}>
                Edit
              </Button>
              <Button size="small" variant="danger" onClick={() => console.log(\`Delete user \${user.id}\`)}>
                Delete
              </Button>
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}
      `)

      // Î©îÏù∏ App Ïª¥Ìè¨ÎÑåÌä∏
      await fs.writeFile(path.join(srcDir, "App.tsx"), `
import React from "react"
import { BrowserRouter as Router, Routes, Route, Link } from "react-router-dom"
import { UserList } from "@components/UserList"
import { Button } from "@components/Button"
import { useLocalStorage } from "@hooks/useLocalStorage"

function Home() {
  const [theme, setTheme] = useLocalStorage("theme", "light")

  const toggleTheme = () => {
    setTheme(theme === "light" ? "dark" : "light")
  }

  return (
    <div className={\`min-h-screen \${theme === "dark" ? "bg-gray-900 text-white" : "bg-white text-black"}\`}>
      <header className="p-4 border-b">
        <nav className="flex justify-between items-center">
          <h1 className="text-2xl font-bold">React Test App</h1>
          <div className="space-x-4">
            <Link to="/" className="hover:underline">Home</Link>
            <Link to="/users" className="hover:underline">Users</Link>
            <Button size="small" onClick={toggleTheme}>
              Toggle Theme ({theme})
            </Button>
          </div>
        </nav>
      </header>
      <main className="p-4">
        <Routes>
          <Route path="/" element={
            <div>
              <h2 className="text-xl mb-4">Welcome to React Test App</h2>
              <p>This is a test application for dependency analysis.</p>
            </div>
          } />
          <Route path="/users" element={<UserList />} />
        </Routes>
      </main>
    </div>
  )
}

export default function App() {
  return (
    <Router>
      <Home />
    </Router>
  )
}
      `)

      // ÏßÑÏûÖÏ†ê
      await fs.writeFile(path.join(srcDir, "main.tsx"), `
import React from "react"
import ReactDOM from "react-dom/client"
import App from "./App"
import "./index.css"

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)
      `)

      await fs.writeFile(path.join(srcDir, "index.css"), `
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
      `)

      // ÌÖåÏä§Ìä∏ ÌååÏùºÎì§
      await fs.writeFile(path.join(testsDir, "Button.test.tsx"), `
import React from "react"
import { render, screen, fireEvent } from "@testing-library/react"
import { Button } from "../src/components/Button"

describe("Button Component", () => {
  test("renders button with text", () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText("Click me")).toBeInTheDocument()
  })

  test("calls onClick when clicked", () => {
    const mockClick = jest.fn()
    render(<Button onClick={mockClick}>Click me</Button>)

    fireEvent.click(screen.getByText("Click me"))
    expect(mockClick).toHaveBeenCalledTimes(1)
  })

  test("is disabled when disabled prop is true", () => {
    render(<Button disabled>Disabled Button</Button>)
    expect(screen.getByText("Disabled Button")).toBeDisabled()
  })
})
      `)

      await fs.writeFile(path.join(testsDir, "api.test.ts"), `
import { ApiClient } from "../src/utils/api"
import axios from "axios"

jest.mock("axios")
const mockedAxios = axios as jest.Mocked<typeof axios>

describe("ApiClient", () => {
  let apiClient: ApiClient

  beforeEach(() => {
    apiClient = new ApiClient("https://api.test.com")
    jest.clearAllMocks()
  })

  test("get method returns data successfully", async () => {
    const mockData = { id: 1, name: "Test User" }
    mockedAxios.get.mockResolvedValueOnce({
      data: mockData,
      status: 200,
      statusText: "OK",
      headers: {},
      config: {}
    })

    const result = await apiClient.get<typeof mockData>("/users/1")

    expect(result.data).toEqual(mockData)
    expect(result.status).toBe(200)
    expect(mockedAxios.get).toHaveBeenCalledWith("https://api.test.com/users/1")
  })

  test("get method throws error on failure", async () => {
    mockedAxios.get.mockRejectedValueOnce(new Error("Network Error"))

    await expect(apiClient.get("/users/1")).rejects.toThrow("API Error")
  })
})
      `)

      // Ï†ÑÏ≤¥ ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù
      const result = execSync(`node "${CLI_PATH}" classify "${projectDir}" --output-dir "${path.join(projectDir, "analysis")}" --verbose`, {
        encoding: "utf-8"
      })

      expect(result).toContain("üìÇ Î∞úÍ≤¨Îêú ÌååÏùº Î∂ÑÎ•ò ÏãúÏûë...")
      expect(result).toContain("üìä ÏùòÏ°¥ÏÑ± Î∂ÑÎ•ò Î∂ÑÏÑù Í≤∞Í≥º")
      expect(result).toContain("üìã ÎÖ∏Îìú ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨:")
      expect(result).toContain("üß™ test:") // ÌÖåÏä§Ìä∏ ÌååÏùº Í∞êÏßÄ
      expect(result).toContain("üìÑ code:") // ÏΩîÎìú ÌååÏùº Í∞êÏßÄ
      expect(result).toContain("üì¶ library:") // ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏùòÏ°¥ÏÑ± Í∞êÏßÄ
      expect(result).toContain("‚úÖ Î∂ÑÏÑù ÏôÑÎ£å!")

      // Î∂ÑÏÑù Í≤∞Í≥º ÌååÏùº ÌôïÏù∏
      const analysisDir = path.join(projectDir, "analysis")
      const reportPath = path.join(analysisDir, "analysis-report.json")
      await expect(fs.access(reportPath)).resolves.toBeUndefined()

      const reportContent = await fs.readFile(reportPath, "utf-8")
      const report = JSON.parse(reportContent)

      expect(report).toHaveProperty("graph")
      expect(report).toHaveProperty("nodesByType")
      expect(report.analysisMetadata.filesProcessed).toBeGreaterThan(10)
    }, LONG_TIMEOUT)
  })

  describe("Node.js Î∞±ÏóîÎìú ÌîÑÎ°úÏ†ùÌä∏ ÏãúÎÇòÎ¶¨Ïò§", () => {
    test("Express API ÏÑúÎ≤Ñ ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù", async () => {
      const projectDir = path.join(TEST_FIXTURES_DIR, "express-api")
      const srcDir = path.join(projectDir, "src")
      const routesDir = path.join(srcDir, "routes")
      const middlewareDir = path.join(srcDir, "middleware")
      const modelsDir = path.join(srcDir, "models")
      const servicesDir = path.join(srcDir, "services")
      const testDir = path.join(projectDir, "test")

      await fs.mkdir(routesDir, { recursive: true })
      await fs.mkdir(middlewareDir, { recursive: true })
      await fs.mkdir(modelsDir, { recursive: true })
      await fs.mkdir(servicesDir, { recursive: true })
      await fs.mkdir(testDir, { recursive: true })

      // package.json
      await fs.writeFile(path.join(projectDir, "package.json"), `
{
  "name": "express-api-test",
  "version": "1.0.0",
  "type": "module",
  "dependencies": {
    "express": "^4.18.0",
    "cors": "^2.8.5",
    "helmet": "^6.0.0",
    "morgan": "^1.10.0",
    "dotenv": "^16.0.0",
    "mongoose": "^7.0.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.0",
    "@types/cors": "^2.8.13",
    "@types/morgan": "^1.9.4",
    "@types/bcryptjs": "^2.4.2",
    "@types/jsonwebtoken": "^9.0.0",
    "typescript": "^5.0.0",
    "nodemon": "^2.0.20",
    "jest": "^29.0.0",
    "supertest": "^6.3.0"
  }
}
      `)

      // Models
      await fs.writeFile(path.join(modelsDir, "User.ts"), `
import mongoose, { Document, Schema } from "mongoose"

export interface IUser extends Document {
  email: string
  password: string
  name: string
  role: "user" | "admin"
  createdAt: Date
  updatedAt: Date
}

const UserSchema: Schema = new Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  name: {
    type: String,
    required: true
  },
  role: {
    type: String,
    enum: ["user", "admin"],
    default: "user"
  }
}, {
  timestamps: true
})

export const User = mongoose.model<IUser>("User", UserSchema)
      `)

      await fs.writeFile(path.join(modelsDir, "Post.ts"), `
import mongoose, { Document, Schema } from "mongoose"
import { IUser } from "./User.js"

export interface IPost extends Document {
  title: string
  content: string
  author: IUser["_id"]
  tags: string[]
  published: boolean
  createdAt: Date
  updatedAt: Date
}

const PostSchema: Schema = new Schema({
  title: {
    type: String,
    required: true,
    maxlength: 200
  },
  content: {
    type: String,
    required: true
  },
  author: {
    type: Schema.Types.ObjectId,
    ref: "User",
    required: true
  },
  tags: [{
    type: String
  }],
  published: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
})

export const Post = mongoose.model<IPost>("Post", PostSchema)
      `)

      // Services
      await fs.writeFile(path.join(servicesDir, "AuthService.ts"), `
import bcrypt from "bcryptjs"
import jwt from "jsonwebtoken"
import { User, IUser } from "../models/User.js"

export class AuthService {
  static async hashPassword(password: string): Promise<string> {
    const salt = await bcrypt.genSalt(10)
    return bcrypt.hash(password, salt)
  }

  static async comparePassword(password: string, hashedPassword: string): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword)
  }

  static generateToken(userId: string): string {
    return jwt.sign(
      { userId },
      process.env.JWT_SECRET || "default-secret",
      { expiresIn: "7d" }
    )
  }

  static verifyToken(token: string): any {
    return jwt.verify(token, process.env.JWT_SECRET || "default-secret")
  }

  static async createUser(userData: Partial<IUser>): Promise<IUser> {
    if (!userData.password) {
      throw new Error("Password is required")
    }

    const hashedPassword = await this.hashPassword(userData.password)
    const user = new User({
      ...userData,
      password: hashedPassword
    })

    return user.save()
  }

  static async authenticateUser(email: string, password: string): Promise<{ user: IUser; token: string } | null> {
    const user = await User.findOne({ email })
    if (!user) {
      return null
    }

    const isValidPassword = await this.comparePassword(password, user.password)
    if (!isValidPassword) {
      return null
    }

    const token = this.generateToken(user._id.toString())
    return { user, token }
  }
}
      `)

      await fs.writeFile(path.join(servicesDir, "PostService.ts"), `
import { Post, IPost } from "../models/Post.js"
import { User } from "../models/User.js"

export class PostService {
  static async createPost(postData: Partial<IPost>): Promise<IPost> {
    const post = new Post(postData)
    return post.save()
  }

  static async getPostById(id: string): Promise<IPost | null> {
    return Post.findById(id).populate("author", "name email").exec()
  }

  static async getAllPosts(page = 1, limit = 10, published = true): Promise<{
    posts: IPost[]
    total: number
    pages: number
  }> {
    const skip = (page - 1) * limit
    const filter = published ? { published: true } : {}

    const [posts, total] = await Promise.all([
      Post.find(filter)
        .populate("author", "name email")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .exec(),
      Post.countDocuments(filter)
    ])

    return {
      posts,
      total,
      pages: Math.ceil(total / limit)
    }
  }

  static async updatePost(id: string, updateData: Partial<IPost>): Promise<IPost | null> {
    return Post.findByIdAndUpdate(id, updateData, { new: true })
      .populate("author", "name email")
      .exec()
  }

  static async deletePost(id: string): Promise<boolean> {
    const result = await Post.findByIdAndDelete(id)
    return !!result
  }

  static async getPostsByAuthor(authorId: string): Promise<IPost[]> {
    return Post.find({ author: authorId })
      .populate("author", "name email")
      .sort({ createdAt: -1 })
      .exec()
  }
}
      `)

      // Middleware
      await fs.writeFile(path.join(middlewareDir, "auth.ts"), `
import { Request, Response, NextFunction } from "express"
import { AuthService } from "../services/AuthService.js"
import { User, IUser } from "../models/User.js"

interface AuthRequest extends Request {
  user?: IUser
}

export const authenticateToken = async (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers["authorization"]
  const token = authHeader && authHeader.split(" ")[1]

  if (!token) {
    return res.status(401).json({ error: "Access token required" })
  }

  try {
    const decoded = AuthService.verifyToken(token)
    const user = await User.findById(decoded.userId)

    if (!user) {
      return res.status(401).json({ error: "Invalid token" })
    }

    req.user = user
    next()
  } catch (error) {
    return res.status(403).json({ error: "Invalid or expired token" })
  }
}

export const requireAdmin = (req: AuthRequest, res: Response, next: NextFunction) => {
  if (!req.user || req.user.role !== "admin") {
    return res.status(403).json({ error: "Admin access required" })
  }
  next()
}
      `)

      await fs.writeFile(path.join(middlewareDir, "validation.ts"), `
import { Request, Response, NextFunction } from "express"

export const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/
  return emailRegex.test(email)
}

export const validatePassword = (password: string): boolean => {
  return password.length >= 6
}

export const validateUserRegistration = (req: Request, res: Response, next: NextFunction) => {
  const { email, password, name } = req.body

  if (!email || !validateEmail(email)) {
    return res.status(400).json({ error: "Valid email is required" })
  }

  if (!password || !validatePassword(password)) {
    return res.status(400).json({ error: "Password must be at least 6 characters" })
  }

  if (!name || name.trim().length < 2) {
    return res.status(400).json({ error: "Name must be at least 2 characters" })
  }

  next()
}

export const validatePostCreation = (req: Request, res: Response, next: NextFunction) => {
  const { title, content } = req.body

  if (!title || title.trim().length < 1) {
    return res.status(400).json({ error: "Title is required" })
  }

  if (!content || content.trim().length < 1) {
    return res.status(400).json({ error: "Content is required" })
  }

  if (title.length > 200) {
    return res.status(400).json({ error: "Title must be less than 200 characters" })
  }

  next()
}
      `)

      // Routes
      await fs.writeFile(path.join(routesDir, "auth.ts"), `
import { Router, Request, Response } from "express"
import { AuthService } from "../services/AuthService.js"
import { validateUserRegistration } from "../middleware/validation.js"

const router = Router()

router.post("/register", validateUserRegistration, async (req: Request, res: Response) => {
  try {
    const { email, password, name } = req.body

    const user = await AuthService.createUser({ email, password, name })
    const token = AuthService.generateToken(user._id.toString())

    res.status(201).json({
      message: "User created successfully",
      user: {
        id: user._id,
        email: user.email,
        name: user.name,
        role: user.role
      },
      token
    })
  } catch (error: any) {
    if (error.code === 11000) {
      return res.status(400).json({ error: "Email already exists" })
    }
    res.status(500).json({ error: "Internal server error" })
  }
})

router.post("/login", async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body

    if (!email || !password) {
      return res.status(400).json({ error: "Email and password are required" })
    }

    const result = await AuthService.authenticateUser(email, password)

    if (!result) {
      return res.status(401).json({ error: "Invalid credentials" })
    }

    res.json({
      message: "Login successful",
      user: {
        id: result.user._id,
        email: result.user.email,
        name: result.user.name,
        role: result.user.role
      },
      token: result.token
    })
  } catch (error) {
    res.status(500).json({ error: "Internal server error" })
  }
})

export default router
      `)

      await fs.writeFile(path.join(routesDir, "posts.ts"), `
import { Router, Request, Response } from "express"
import { PostService } from "../services/PostService.js"
import { authenticateToken, requireAdmin } from "../middleware/auth.js"
import { validatePostCreation } from "../middleware/validation.js"
import { IUser } from "../models/User.js"

interface AuthRequest extends Request {
  user?: IUser
}

const router = Router()

router.get("/", async (req: Request, res: Response) => {
  try {
    const page = parseInt(req.query.page as string) || 1
    const limit = parseInt(req.query.limit as string) || 10
    const published = req.query.published !== "false"

    const result = await PostService.getAllPosts(page, limit, published)
    res.json(result)
  } catch (error) {
    res.status(500).json({ error: "Internal server error" })
  }
})

router.get("/:id", async (req: Request, res: Response) => {
  try {
    const post = await PostService.getPostById(req.params.id)

    if (!post) {
      return res.status(404).json({ error: "Post not found" })
    }

    res.json(post)
  } catch (error) {
    res.status(500).json({ error: "Internal server error" })
  }
})

router.post("/", authenticateToken, validatePostCreation, async (req: AuthRequest, res: Response) => {
  try {
    const postData = {
      ...req.body,
      author: req.user!._id
    }

    const post = await PostService.createPost(postData)
    res.status(201).json(post)
  } catch (error) {
    res.status(500).json({ error: "Internal server error" })
  }
})

router.put("/:id", authenticateToken, validatePostCreation, async (req: AuthRequest, res: Response) => {
  try {
    const post = await PostService.getPostById(req.params.id)

    if (!post) {
      return res.status(404).json({ error: "Post not found" })
    }

    // ÏûëÏÑ±Ïûê ÎòêÎäî Í¥ÄÎ¶¨ÏûêÎßå ÏàòÏ†ï Í∞ÄÎä•
    if (post.author._id.toString() !== req.user!._id.toString() && req.user!.role !== "admin") {
      return res.status(403).json({ error: "Access denied" })
    }

    const updatedPost = await PostService.updatePost(req.params.id, req.body)
    res.json(updatedPost)
  } catch (error) {
    res.status(500).json({ error: "Internal server error" })
  }
})

router.delete("/:id", authenticateToken, async (req: AuthRequest, res: Response) => {
  try {
    const post = await PostService.getPostById(req.params.id)

    if (!post) {
      return res.status(404).json({ error: "Post not found" })
    }

    // ÏûëÏÑ±Ïûê ÎòêÎäî Í¥ÄÎ¶¨ÏûêÎßå ÏÇ≠Ï†ú Í∞ÄÎä•
    if (post.author._id.toString() !== req.user!._id.toString() && req.user!.role !== "admin") {
      return res.status(403).json({ error: "Access denied" })
    }

    await PostService.deletePost(req.params.id)
    res.json({ message: "Post deleted successfully" })
  } catch (error) {
    res.status(500).json({ error: "Internal server error" })
  }
})

export default router
      `)

      // Main app
      await fs.writeFile(path.join(srcDir, "app.ts"), `
import express from "express"
import cors from "cors"
import helmet from "helmet"
import morgan from "morgan"
import dotenv from "dotenv"
import mongoose from "mongoose"

import authRoutes from "./routes/auth.js"
import postsRoutes from "./routes/posts.js"

dotenv.config()

const app = express()
const PORT = process.env.PORT || 3000

// Middleware
app.use(helmet())
app.use(cors())
app.use(morgan("combined"))
app.use(express.json({ limit: "10mb" }))
app.use(express.urlencoded({ extended: true }))

// Routes
app.use("/api/auth", authRoutes)
app.use("/api/posts", postsRoutes)

// Health check
app.get("/health", (req, res) => {
  res.json({ status: "ok", timestamp: new Date().toISOString() })
})

// 404 handler
app.use("*", (req, res) => {
  res.status(404).json({ error: "Route not found" })
})

// Error handler
app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error(err.stack)
  res.status(500).json({ error: "Something went wrong!" })
})

// Database connection
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI || "mongodb://localhost:27017/test")
    console.log("MongoDB connected successfully")
  } catch (error) {
    console.error("MongoDB connection error:", error)
    process.exit(1)
  }
}

// Start server
const startServer = async () => {
  await connectDB()

  app.listen(PORT, () => {
    console.log(\`Server running on port \${PORT}\`)
  })
}

if (process.env.NODE_ENV !== "test") {
  startServer()
}

export default app
      `)

      // ÌÖåÏä§Ìä∏ ÌååÏùºÎì§
      await fs.writeFile(path.join(testDir, "auth.test.ts"), `
import request from "supertest"
import app from "../src/app.js"
import { User } from "../src/models/User.js"

describe("Auth Routes", () => {
  beforeEach(async () => {
    await User.deleteMany({})
  })

  describe("POST /api/auth/register", () => {
    test("should register a new user", async () => {
      const userData = {
        email: "test@example.com",
        password: "password123",
        name: "Test User"
      }

      const response = await request(app)
        .post("/api/auth/register")
        .send(userData)

      expect(response.status).toBe(201)
      expect(response.body.user.email).toBe(userData.email)
      expect(response.body.token).toBeDefined()
    })

    test("should not register user with invalid email", async () => {
      const userData = {
        email: "invalid-email",
        password: "password123",
        name: "Test User"
      }

      const response = await request(app)
        .post("/api/auth/register")
        .send(userData)

      expect(response.status).toBe(400)
      expect(response.body.error).toContain("email")
    })
  })

  describe("POST /api/auth/login", () => {
    test("should login with valid credentials", async () => {
      const userData = {
        email: "test@example.com",
        password: "password123",
        name: "Test User"
      }

      // Register user first
      await request(app).post("/api/auth/register").send(userData)

      // Login
      const response = await request(app)
        .post("/api/auth/login")
        .send({
          email: userData.email,
          password: userData.password
        })

      expect(response.status).toBe(200)
      expect(response.body.token).toBeDefined()
    })

    test("should not login with invalid credentials", async () => {
      const response = await request(app)
        .post("/api/auth/login")
        .send({
          email: "test@example.com",
          password: "wrongpassword"
        })

      expect(response.status).toBe(401)
      expect(response.body.error).toContain("Invalid credentials")
    })
  })
})
      `)

      await fs.writeFile(path.join(testDir, "posts.test.ts"), `
import request from "supertest"
import app from "../src/app.js"
import { User } from "../src/models/User.js"
import { Post } from "../src/models/Post.js"
import { AuthService } from "../src/services/AuthService.js"

describe("Posts Routes", () => {
  let authToken: string
  let userId: string

  beforeEach(async () => {
    await User.deleteMany({})
    await Post.deleteMany({})

    // Create a test user
    const user = await AuthService.createUser({
      email: "test@example.com",
      password: "password123",
      name: "Test User"
    })

    userId = user._id.toString()
    authToken = AuthService.generateToken(userId)
  })

  describe("GET /api/posts", () => {
    test("should get all published posts", async () => {
      // Create some test posts
      await Post.create([
        { title: "Post 1", content: "Content 1", author: userId, published: true },
        { title: "Post 2", content: "Content 2", author: userId, published: false },
        { title: "Post 3", content: "Content 3", author: userId, published: true }
      ])

      const response = await request(app).get("/api/posts")

      expect(response.status).toBe(200)
      expect(response.body.posts).toHaveLength(2) // Only published posts
      expect(response.body.total).toBe(2)
    })
  })

  describe("POST /api/posts", () => {
    test("should create a new post", async () => {
      const postData = {
        title: "Test Post",
        content: "This is a test post",
        tags: ["test", "api"]
      }

      const response = await request(app)
        .post("/api/posts")
        .set("Authorization", \`Bearer \${authToken}\`)
        .send(postData)

      expect(response.status).toBe(201)
      expect(response.body.title).toBe(postData.title)
      expect(response.body.author).toBe(userId)
    })

    test("should not create post without authentication", async () => {
      const postData = {
        title: "Test Post",
        content: "This is a test post"
      }

      const response = await request(app)
        .post("/api/posts")
        .send(postData)

      expect(response.status).toBe(401)
    })
  })
})
      `)

      // ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù Ïã§Ìñâ
      const result = execSync(`node "${CLI_PATH}" analyze "${projectDir}" --verbose`, {
        encoding: "utf-8"
      })

      expect(result).toContain("üîç Starting analysis of:")
      expect(result).toContain("üìÅ Found")
      expect(result).toContain("files to analyze")
      expect(result).toContain("üìä Analysis completed:")

      // ÌååÏùº Ïàò ÌôïÏù∏ (ÏµúÏÜå 15Í∞ú Ïù¥ÏÉÅÏùò TypeScript ÌååÏùºÏù¥ ÏûàÏñ¥Ïïº Ìï®)
      const filesMatch = result.match(/üìÅ Found (\d+) files to analyze/)
      expect(filesMatch).toBeTruthy()
      expect(parseInt(filesMatch![1])).toBeGreaterThan(15)
    }, LONG_TIMEOUT)
  })

  describe("ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏ ÏûêÏ≤¥ Î∂ÑÏÑù", () => {
    test("deps-cli ÌîÑÎ°úÏ†ùÌä∏ ÏûêÏ≤¥ Î∂ÑÏÑù", async () => {
      const result = execSync(`node "${CLI_PATH}" classify "${PROJECT_ROOT}" --verbose`, {
        encoding: "utf-8",
        cwd: PROJECT_ROOT
      })

      expect(result).toContain("üìÇ Î∞úÍ≤¨Îêú ÌååÏùº Î∂ÑÎ•ò ÏãúÏûë...")
      expect(result).toContain("üìä ÏùòÏ°¥ÏÑ± Î∂ÑÎ•ò Î∂ÑÏÑù Í≤∞Í≥º")
      expect(result).toContain("üìÅ Ï¥ù ÌååÏùº:")
      expect(result).toContain("üîó Ï¥ù ÏùòÏ°¥ÏÑ±:")
      expect(result).toContain("üìã ÎÖ∏Îìú ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨:")
      expect(result).toContain("üìÑ code:") // ÏΩîÎìú ÌååÏùºÎì§Ïù¥ Î∂ÑÏÑùÎêòÏóàÎäîÏßÄ ÌôïÏù∏

      // Î∂ÑÏÑùÎêú ÌååÏùº ÏàòÍ∞Ä Ìï©Î¶¨Ï†ÅÏù∏ÏßÄ ÌôïÏù∏
      const filesMatch = result.match(/üìÅ Ï¥ù ÌååÏùº: (\d+)Í∞ú/)
      expect(filesMatch).toBeTruthy()
      expect(parseInt(filesMatch![1])).toBeGreaterThan(5) // ÏµúÏÜå Î™á Í∞úÏùò ÌååÏùºÏùÄ ÏûàÏñ¥Ïïº Ìï®
    }, LONG_TIMEOUT)

    test("ÏÜåÏä§ ÏΩîÎìú ÎîîÎ†âÌÜ†Î¶¨Îßå Î∂ÑÏÑù", async () => {
      const srcPath = path.join(PROJECT_ROOT, "src")

      const result = execSync(`node "${CLI_PATH}" analyze "${srcPath}" --verbose`, {
        encoding: "utf-8"
      })

      const lines = result.split("\n")
      const jsonStart = lines.findIndex(line => line.trim().startsWith("{"))
      const jsonContent = lines.slice(jsonStart).join("\n")

      expect(() => JSON.parse(jsonContent)).not.toThrow()

      const analysis = JSON.parse(jsonContent)
      expect(analysis).toHaveProperty("graph")
      expect(analysis).toHaveProperty("analysisMetadata")
      expect(analysis.analysisMetadata.filesProcessed).toBeGreaterThan(0)
    }, LONG_TIMEOUT)
  })

  describe("ÏõåÌÅ¨ÌîåÎ°úÏö∞ ÏãúÎÆ¨Î†àÏù¥ÏÖò", () => {
    test("Í∞úÎ∞ú ÏõåÌÅ¨ÌîåÎ°úÏö∞: ÏΩîÎìú ÏûëÏÑ± ‚Üí Î∂ÑÏÑù ‚Üí ÏàòÏ†ï ‚Üí Ïû¨Î∂ÑÏÑù", async () => {
      const workflowDir = path.join(TEST_FIXTURES_DIR, "workflow")
      await fs.mkdir(workflowDir, { recursive: true })

      // 1Îã®Í≥Ñ: Ï¥àÍ∏∞ ÏΩîÎìú ÏûëÏÑ±
      await fs.writeFile(path.join(workflowDir, "index.ts"), `
import { helper } from "./helper"

export function main() {
  return helper()
}
      `)

      await fs.writeFile(path.join(workflowDir, "helper.ts"), `
export function helper() {
  return "initial version"
}
      `)

      // Ï≤´ Î≤àÏß∏ Î∂ÑÏÑù
      const firstAnalysis = execSync(`node "${CLI_PATH}" analyze "${workflowDir}"`, {
        encoding: "utf-8"
      })

      const firstResult = JSON.parse(firstAnalysis)
      expect(firstResult.analysisMetadata.filesProcessed).toBe(2)

      // 2Îã®Í≥Ñ: ÏΩîÎìú ÏàòÏ†ï Î∞è Ï∂îÍ∞Ä
      await fs.writeFile(path.join(workflowDir, "utils.ts"), `
export function formatString(str: string): string {
  return str.toUpperCase()
}

export function processData(data: any[]): any[] {
  return data.map(item => ({
    ...item,
    processed: true
  }))
}
      `)

      await fs.writeFile(path.join(workflowDir, "helper.ts"), `
import { formatString } from "./utils"

export function helper() {
  return formatString("updated version")
}

export function advancedHelper(data: any[]) {
  const { processData } = require("./utils")
  return processData(data)
}
      `)

      // Îëê Î≤àÏß∏ Î∂ÑÏÑù
      const secondAnalysis = execSync(`node "${CLI_PATH}" analyze "${workflowDir}"`, {
        encoding: "utf-8"
      })

      const secondResult = JSON.parse(secondAnalysis)
      expect(secondResult.analysisMetadata.filesProcessed).toBe(3)

      // ÏùòÏ°¥ÏÑ±Ïù¥ Ï¶ùÍ∞ÄÌñàÎäîÏßÄ ÌôïÏù∏
      const firstDepsCount = Object.keys(firstResult.graph).length
      const secondDepsCount = Object.keys(secondResult.graph).length
      expect(secondDepsCount).toBeGreaterThanOrEqual(firstDepsCount)
    })

    test("CI/CD ÏãúÎÆ¨Î†àÏù¥ÏÖò: ÏΩîÎìú Î∂ÑÏÑù ‚Üí Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ‚Üí Í≤ÄÏ¶ù", async () => {
      const cicdDir = path.join(TEST_FIXTURES_DIR, "cicd")
      const outputDir = path.join(cicdDir, "reports")
      await fs.mkdir(cicdDir, { recursive: true })

      // ÌîÑÎ°úÏ†ùÌä∏ ÌååÏùºÎì§ ÏÉùÏÑ±
      await fs.writeFile(path.join(cicdDir, "package.json"), `
{
  "name": "cicd-test-project",
  "dependencies": {
    "express": "^4.18.0",
    "lodash": "^4.17.21"
  }
}
      `)

      await fs.writeFile(path.join(cicdDir, "src.ts"), `
import express from "express"
import _ from "lodash"

const app = express()

app.get("/", (req, res) => {
  const data = _.shuffle([1, 2, 3, 4, 5])
  res.json({ data })
})

export default app
      `)

      // CI/CD Ïä§ÌÉÄÏùº Î∂ÑÏÑù (Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±)
      const result = execSync(`node "${CLI_PATH}" classify "${cicdDir}" --output-dir "${outputDir}" --verbose`, {
        encoding: "utf-8"
      })

      expect(result).toContain("‚úÖ Î∂ÑÏÑù ÏôÑÎ£å!")
      expect(result).toContain("üíæ Í≤∞Í≥º Ï†ÄÏû•Îê®:")

      // Î¶¨Ìè¨Ìä∏ ÌååÏùº ÌôïÏù∏
      const reportPath = path.join(outputDir, "analysis-report.json")
      await expect(fs.access(reportPath)).resolves.toBeUndefined()

      // Î¶¨Ìè¨Ìä∏ ÎÇ¥Ïö© Í≤ÄÏ¶ù
      const reportContent = await fs.readFile(reportPath, "utf-8")
      const report = JSON.parse(reportContent)

      expect(report).toHaveProperty("graph")
      expect(report).toHaveProperty("analysisMetadata")
      expect(report.analysisMetadata).toHaveProperty("startTime")
      expect(report.analysisMetadata).toHaveProperty("endTime")
      expect(report.analysisMetadata).toHaveProperty("filesProcessed")

      // ÏùòÏ°¥ÏÑ± Í≤ÄÏ¶ù
      const dependencies = Object.keys(report.graph)
      expect(dependencies.length).toBeGreaterThan(0)
    })
  })
})