const { EnhancedDependencyAnalyzer } = require('./dist/analyzers/EnhancedDependencyAnalyzer.js');
const { DependencyDataCollector } = require('./dist/utils/DependencyDataCollector.js');
const { DocumentPathGenerator } = require('./dist/utils/DocumentPathGenerator.js');
const fs = require('fs/promises');
const path = require('path');

async function updateAll() {
  console.log('ğŸš€ ì „ì²´ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì—…ë°ì´íŠ¸ ì‹œì‘...\n');

  const analyzer = new EnhancedDependencyAnalyzer('.');
  const collector = new DependencyDataCollector(process.cwd());
  const pathGenerator = new DocumentPathGenerator();

  // 1ë‹¨ê³„: ì˜ì¡´ì„± ë¶„ì„
  console.log('ğŸ“Š 1ë‹¨ê³„: ì˜ì¡´ì„± ë¶„ì„ ì¤‘...');
  const graph = await analyzer.buildProjectDependencyGraph();
  console.log(`   âœ… ${graph.nodes.size}ê°œ íŒŒì¼, ${graph.edges.length}ê°œ ì˜ì¡´ì„± ë¶„ì„ ì™„ë£Œ\n`);

  // 2ë‹¨ê³„: ì„¤ì • ë¡œë“œ
  console.log('ğŸ“‹ 2ë‹¨ê³„: ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì„¤ì • ë¡œë“œ ì¤‘...');
  const configContent = await fs.readFile('deps-cli.json', 'utf-8');
  const config = JSON.parse(configContent);

  const rules = Object.entries(config.namespaces).map(([namespace, rule]) => ({
    namespace,
    ...rule
  }));
  console.log(`   âœ… ${rules.length}ê°œ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì„¤ì • ë¡œë“œ ì™„ë£Œ\n`);

  // 3ë‹¨ê³„: ë°ì´í„° ìˆ˜ì§‘
  console.log('ğŸ” 3ë‹¨ê³„: ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë³„ ë°ì´í„° ìˆ˜ì§‘ ì¤‘...');
  const results = [];
  for (const rule of rules) {
    const result = collector.collectForNamespace(graph, rule);
    results.push(result);
    console.log(`   ğŸ“ ${rule.namespace} (${rule.documentStrategy}): ${result.totalCount}ê°œ í•­ëª©`);
  }
  console.log();

  // 4ë‹¨ê³„: ê²½ë¡œ ìƒì„± ë° ë¬¸ì„œ ìƒì„±
  console.log('ğŸ“ 4ë‹¨ê³„: ë¬¸ì„œ ê²½ë¡œ ìƒì„± ë° íŒŒì¼ ìƒì„± ì¤‘...');
  let totalCreated = 0;

  for (const result of results) {
    const rule = rules.find(r => r.namespace === result.namespace);
    if (!rule) continue;

    const paths = pathGenerator.generatePathsWithStrategy(result, rule);
    console.log(`   ğŸ“„ ${rule.namespace}: ${paths.length}ê°œ ê²½ë¡œ`);

    // ê° ê²½ë¡œì— ëŒ€í•´ ë¬¸ì„œ ìƒì„±
    for (const docPath of paths) {
      const fullPath = path.resolve(docPath.documentPath);
      const dir = path.dirname(fullPath);

      try {
        // ë””ë ‰í† ë¦¬ ìƒì„±
        await fs.mkdir(dir, { recursive: true });

        // ë¬¸ì„œ ë‚´ìš© ìƒì„±
        const strategy = rule.documentStrategy || 'file-mirror';
        let content = '';

        if (strategy === 'file-mirror') {
          content = `# ${docPath.sourceItem.value}

## ğŸ“„ File Mirror

**Namespace:** ${docPath.namespace}
**Strategy:** file-mirror
**Source:** \`${docPath.sourceItem.sourcePath}\`
**Pattern:** \`${docPath.sourceItem.matchedPattern}\`

## ğŸ“‹ File Information

- **Type:** ${docPath.sourceItem.type}
- **Value:** ${docPath.sourceItem.value}

## ğŸ” Metadata

\`\`\`json
${JSON.stringify(docPath.sourceItem.metadata || {}, null, 2)}
\`\`\`

---
*Generated by deps-cli ${new Date().toISOString()}*
`;
        } else if (strategy === 'method-mirror') {
          content = `# ${docPath.sourceItem.value}

## ğŸ”§ Method Mirror

**Namespace:** ${docPath.namespace}
**Strategy:** method-mirror
**Source:** \`${docPath.sourceItem.sourcePath}\`
**Pattern:** \`${docPath.sourceItem.matchedPattern}\`

## ğŸ“ Method Information

- **Type:** ${docPath.sourceItem.type}
- **Value:** ${docPath.sourceItem.value}

## ğŸ—ï¸ Structure

\`\`\`json
${JSON.stringify(docPath.sourceItem.metadata || {}, null, 2)}
\`\`\`

---
*Generated by deps-cli ${new Date().toISOString()}*
`;
        } else if (strategy === 'library-structure') {
          const libraryName = docPath.templateVariables.library || 'unknown'
          const methodName = docPath.templateVariables.method || docPath.sourceItem.value
          const isExternal = docPath.templateVariables.isExternal || false

          content = `# ${methodName}

## ğŸ“¦ Library Structure

**Library:** \`${libraryName}\`
**Method:** \`${methodName}\`
**Namespace:** ${docPath.namespace}
**Strategy:** library-structure
**Source:** ${isExternal ? 'External Library' : docPath.sourceItem.sourcePath}
**Pattern:** \`${docPath.sourceItem.matchedPattern}\`

## ğŸ“š Library Information

- **Type:** ${docPath.sourceItem.type}
- **Library Name:** ${libraryName}
- **Method Name:** ${methodName}
- **Import Type:** ${docPath.templateVariables.importType || 'unknown'}
- **Is External:** ${isExternal ? 'Yes' : 'No'}

## ğŸ”— Import Details

\`\`\`json
${JSON.stringify(docPath.sourceItem.metadata || {}, null, 2)}
\`\`\`

## ğŸ“– Usage Context

This method is imported from the external library \`${libraryName}\` and used within the project.

---
*Generated by deps-cli ${new Date().toISOString()}*
`;
        } else if (strategy === 'namespace-grouping') {
          content = `# ${docPath.sourceItem.value}

## ğŸ·ï¸ Namespace Grouping

**Namespace:** ${docPath.namespace}
**Strategy:** namespace-grouping
**Source:** \`${docPath.sourceItem.sourcePath}\`
**Pattern:** \`${docPath.sourceItem.matchedPattern}\`

## ğŸ—‚ï¸ Type Information

- **Type:** ${docPath.sourceItem.type}
- **Value:** ${docPath.sourceItem.value}

## ğŸ“Š Type Details

\`\`\`json
${JSON.stringify(docPath.sourceItem.metadata || {}, null, 2)}
\`\`\`

---
*Generated by deps-cli ${new Date().toISOString()}*
`;
        }

        await fs.writeFile(fullPath, content, 'utf-8');
        totalCreated++;

      } catch (error) {
        console.error(`   âŒ ì‹¤íŒ¨: ${docPath.documentPath}`, error.message);
      }
    }
  }

  console.log(`\nğŸ‰ ì „ì²´ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì—…ë°ì´íŠ¸ ì™„ë£Œ!`);
  console.log(`ğŸ“Š ìš”ì•½:`);
  console.log(`   ğŸ“ ë„¤ì„ìŠ¤í˜ì´ìŠ¤: ${results.length}ê°œ`);
  console.log(`   ğŸ“„ ìˆ˜ì§‘ëœ í•­ëª©: ${results.reduce((sum, r) => sum + r.totalCount, 0)}ê°œ`);
  console.log(`   ğŸ“š ìƒì„±ëœ íŒŒì¼: ${totalCreated}ê°œ`);
}

updateAll().catch(console.error);