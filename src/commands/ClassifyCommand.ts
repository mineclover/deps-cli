/**
 * ÏùòÏ°¥ÏÑ± Î∂ÑÎ•ò Î™ÖÎ†πÏñ¥ - ÌååÏùº ÌÉÄÏûÖÎ≥Ñ ÏùòÏ°¥ÏÑ±ÏùÑ Î∂ÑÎ•òÌïòÏó¨ Ï†ÄÏû•ÌïòÎäî CLI Î™ÖÎ†πÏñ¥
 */

import * as Command from "@effect/cli/Command"
import * as Options from "@effect/cli/Options"
import * as Args from "@effect/cli/Args"
import * as Effect from "effect/Effect"
import * as Console from "effect/Console"
import * as Option from "effect/Option"
import * as path from 'node:path'
import * as fs from 'node:fs'

import { UnifiedDependencyAnalyzer } from '../analyzers/UnifiedDependencyAnalyzer.js'
import { MetadataExtractor } from '../analyzers/MetadataExtractor.js'
import type { AnalysisConfig, StorageOptions, NodeType } from '../types/DependencyClassification.js'

// CLI ÏòµÏÖò Ï†ïÏùò
const filePathArg = Args.text({ name: "filePath" }).pipe(
  Args.withDescription("Î∂ÑÏÑùÌï† ÌååÏùº ÎòêÎäî ÎîîÎ†âÌÜ†Î¶¨ Í≤ΩÎ°ú")
)

const outputFormatOption = Options.choice("format", ["json", "sqlite", "neo4j", "graphml"]).pipe(
  Options.withDefault("json" as const),
  Options.withDescription("Ï∂úÎ†• ÌòïÏãù")
)

const outputDirOption = Options.text("output-dir").pipe(
  Options.optional,
  Options.withDescription("Í≤∞Í≥º Ï†ÄÏû• ÎîîÎ†âÌÜ†Î¶¨")
)

const includeTestsOption = Options.boolean("include-tests").pipe(
  Options.withDefault(true),
  Options.withDescription("ÌÖåÏä§Ìä∏ ÌååÏùº Ìè¨Ìï® Ïó¨Î∂Ä")
)

const includeDocsOption = Options.boolean("include-docs").pipe(
  Options.withDefault(true),
  Options.withDescription("Î¨∏ÏÑú ÌååÏùº Ìè¨Ìï® Ïó¨Î∂Ä")
)

const includeNodeModulesOption = Options.boolean("include-node-modules").pipe(
  Options.withDefault(false),
  Options.withDescription("node_modules Ìè¨Ìï® Ïó¨Î∂Ä")
)

const maxDepthOption = Options.integer("max-depth").pipe(
  Options.withDefault(10),
  Options.withDescription("ÏµúÎåÄ ÌÉêÏÉâ ÍπäÏù¥")
)

const verboseOption = Options.boolean("verbose").pipe(
  Options.withDefault(false),
  Options.withAlias("v"),
  Options.withDescription("ÏÉÅÏÑ∏ Ï∂úÎ†• Î™®Îìú")
)

const nodeTypeFilterOption = Options.choice("node-type", ["test", "code", "docs", "library", "all"]).pipe(
  Options.withDefault("all" as const),
  Options.withDescription("Î∂ÑÏÑùÌï† ÎÖ∏Îìú ÌÉÄÏûÖ ÌïÑÌÑ∞")
)

const compressionOption = Options.boolean("compression").pipe(
  Options.withDefault(false),
  Options.withDescription("Í≤∞Í≥º ÏïïÏ∂ï Ïó¨Î∂Ä")
)

const incrementalOption = Options.boolean("incremental").pipe(
  Options.withDefault(false),
  Options.withDescription("Ï¶ùÎ∂Ñ Î∂ÑÏÑù Î™®Îìú")
)

// Í≥†Í∏â Î∂ÑÏÑù ÏòµÏÖòÎì§
const analysisDepthOption = Options.choice("analysis-depth", ["minimal", "standard", "comprehensive", "deep"]).pipe(
  Options.withDefault("standard" as const),
  Options.withDescription("Î∂ÑÏÑù ÍπäÏù¥ Î†àÎ≤® (minimal: Í∏∞Î≥∏Îßå, standard: ÌëúÏ§Ä, comprehensive: Ìè¨Í¥ÑÏ†Å, deep: Ïã¨Ìôî)")
)

const excludePatternsOption = Options.text("exclude").pipe(
  Options.optional,
  Options.withDescription("Ï†úÏô∏Ìï† ÌååÏùº/ÎîîÎ†âÌÜ†Î¶¨ Ìå®ÌÑ¥ (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)")
)

const includePatternsOption = Options.text("include").pipe(
  Options.optional,
  Options.withDescription("Ìè¨Ìï®Ìï† ÌååÏùº Ìå®ÌÑ¥ (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)")
)

const minFileSizeOption = Options.integer("min-file-size").pipe(
  Options.withDefault(0),
  Options.withDescription("Î∂ÑÏÑùÌï† ÏµúÏÜå ÌååÏùº ÌÅ¨Í∏∞ (bytes)")
)

const maxFileSizeOption = Options.integer("max-file-size").pipe(
  Options.withDefault(1024 * 1024 * 10), // 10MB
  Options.withDescription("Î∂ÑÏÑùÌï† ÏµúÎåÄ ÌååÏùº ÌÅ¨Í∏∞ (bytes)")
)

const outputNameOption = Options.text("output-name").pipe(
  Options.optional,
  Options.withDescription("Ï∂úÎ†• ÌååÏùºÎ™Ö (ÌôïÏû•Ïûê Ï†úÏô∏)")
)

const generateReportOption = Options.boolean("generate-report").pipe(
  Options.withDefault(true),
  Options.withDescription("Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ïó¨Î∂Ä")
)

const generateVisualizationOption = Options.boolean("generate-viz").pipe(
  Options.withDefault(false),
  Options.withDescription("ÏãúÍ∞ÅÌôî Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ïó¨Î∂Ä")
)

const confidenceThresholdOption = Options.integer("confidence-threshold").pipe(
  Options.withDefault(50),
  Options.withDescription("ÏùòÏ°¥ÏÑ± Ïã†Î¢∞ÎèÑ ÏûÑÍ≥ÑÍ∞í (0-100%)")
)

const enableCachingOption = Options.boolean("enable-cache").pipe(
  Options.withDefault(true),
  Options.withDescription("Î∂ÑÏÑù Í≤∞Í≥º Ï∫êÏã± ÌôúÏÑ±Ìôî")
)

const parallelProcessingOption = Options.boolean("parallel").pipe(
  Options.withDefault(true),
  Options.withDescription("Î≥ëÎ†¨ Ï≤òÎ¶¨ ÌôúÏÑ±Ìôî")
)

const outputMetadataOption = Options.boolean("output-metadata").pipe(
  Options.withDefault(true),
  Options.withDescription("Ï∞∏Ï°∞ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂úÎ†• Ïó¨Î∂Ä")
)

// Î©îÏù∏ Î™ÖÎ†πÏñ¥
export const classifyCommand = Command.make(
  "classify",
  {
    filePath: filePathArg,
    format: outputFormatOption,
    outputDir: outputDirOption,
    includeTests: includeTestsOption,
    includeDocs: includeDocsOption,
    includeNodeModules: includeNodeModulesOption,
    maxDepth: maxDepthOption,
    verbose: verboseOption,
    nodeType: nodeTypeFilterOption,
    compression: compressionOption,
    incremental: incrementalOption,
    // Í≥†Í∏â ÏòµÏÖòÎì§
    analysisDepth: analysisDepthOption,
    excludePatterns: excludePatternsOption,
    includePatterns: includePatternsOption,
    minFileSize: minFileSizeOption,
    maxFileSize: maxFileSizeOption,
    outputName: outputNameOption,
    generateReport: generateReportOption,
    generateVisualization: generateVisualizationOption,
    confidenceThreshold: confidenceThresholdOption,
    enableCaching: enableCachingOption,
    parallelProcessing: parallelProcessingOption,
    outputMetadata: outputMetadataOption
  }
).pipe(
  Command.withDescription("ÌååÏùº ÌÉÄÏûÖÎ≥Ñ ÏùòÏ°¥ÏÑ±ÏùÑ Î∂ÑÎ•òÌïòÏó¨ Ï†ÄÏû•"),
  Command.withHandler((args) =>
    Effect.gen(function*() {
      const {
        filePath,
        format,
        outputDir,
        includeTests,
        includeDocs,
        includeNodeModules,
        maxDepth,
        verbose,
        nodeType,
        compression,
        incremental,
        // Í≥†Í∏â ÏòµÏÖòÎì§
        analysisDepth,
        excludePatterns,
        includePatterns,
        minFileSize,
        maxFileSize,
        outputName,
        generateReport,
        generateVisualization,
        confidenceThreshold,
        enableCaching,
        parallelProcessing,
        outputMetadata
      } = args

      if (verbose) {
        yield* Console.log(`üîç ÏùòÏ°¥ÏÑ± Î∂ÑÎ•ò Î∂ÑÏÑù ÏãúÏûë: ${filePath}`)
        yield* Console.log(`üìä ÌòïÏãù: ${format}, ÎÖ∏Îìú ÌÉÄÏûÖ: ${nodeType}, ÍπäÏù¥: ${analysisDepth}`)
        yield* Console.log(`üìÅ Ï∂úÎ†•: ${Option.getOrElse(outputDir, () => "Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")}${Option.isSome(outputName) ? `, ÌååÏùºÎ™Ö: ${Option.getOrElse(outputName, () => "")}` : ""}`)
        yield* Console.log(`‚öôÔ∏è ÏÑ§Ï†ï: ÌÖåÏä§Ìä∏=${includeTests}, Î¨∏ÏÑú=${includeDocs}, ÏµúÎåÄÍπäÏù¥=${maxDepth}`)
        yield* Console.log(`üéØ ÌïÑÌÑ∞: Ïã†Î¢∞ÎèÑ>=${confidenceThreshold}%, ÌååÏùºÌÅ¨Í∏∞=${minFileSize}-${maxFileSize}bytes`)

        if (Option.isSome(excludePatterns)) {
          yield* Console.log(`üö´ Ï†úÏô∏ Ìå®ÌÑ¥: ${Option.getOrElse(excludePatterns, () => "")}`)
        }
        if (Option.isSome(includePatterns)) {
          yield* Console.log(`‚úÖ Ìè¨Ìï® Ìå®ÌÑ¥: ${Option.getOrElse(includePatterns, () => "")}`)
        }

        yield* Console.log(`üîß Í≥†Í∏â: Ï∫êÏãú=${enableCaching}, Î≥ëÎ†¨=${parallelProcessing}, Î©îÌÉÄÎç∞Ïù¥ÌÑ∞=${outputMetadata}`)
        yield* Console.log(`üìà ÏÉùÏÑ±: Î¶¨Ìè¨Ìä∏=${generateReport}, ÏãúÍ∞ÅÌôî=${generateVisualization}`)
      }

      // ÌååÏùº ÏãúÏä§ÌÖú Ï≤¥ÌÅ¨
      const isDirectory = yield* Effect.tryPromise(async () => {
        const fs = await import("fs/promises")
        const stat = await fs.stat(filePath)
        return stat.isDirectory()
      })

      // Î∂ÑÏÑùÌï† ÌååÏùºÎì§ ÏàòÏßë
      const files = yield* Effect.tryPromise(async () => {
        if (isDirectory) {
          return await collectFiles(filePath, {
            includeTests,
            includeDocs,
            includeNodeModules,
            maxDepth,
            nodeType: nodeType as NodeType | 'all',
            // ÏÉàÎ°úÏö¥ ÏòµÏÖòÎì§
            excludePatterns: Option.getOrElse(excludePatterns, () => ""),
            includePatterns: Option.getOrElse(includePatterns, () => ""),
            minFileSize,
            maxFileSize,
            confidenceThreshold
          })
        } else {
          return [filePath]
        }
      })

      if (verbose) {
        yield* Console.log(`üìÇ Î∞úÍ≤¨Îêú ÌååÏùº: ${files.length}Í∞ú`)
        for (const file of files) {
          const nodeType = getFileNodeType(file)
          yield* Console.log(`  ‚Ä¢ ${file} (${nodeType})`)
        }
      } else {
        yield* Console.log(`üìÇ Î∞úÍ≤¨Îêú ÌååÏùº: ${files.length}Í∞ú`)
        // Í∏∞Î≥∏ Î™®ÎìúÏóêÏÑúÎèÑ ÌååÏùº ÌÉÄÏûÖ Î∂ÑÌè¨ ÌëúÏãú
        const fileTypeCount = files.reduce((acc, file) => {
          const nodeType = getFileNodeType(file)
          acc[nodeType] = (acc[nodeType] || 0) + 1
          return acc
        }, {} as Record<string, number>)

        for (const [type, count] of Object.entries(fileTypeCount)) {
          yield* Console.log(`  ${type}: ${count}Í∞ú`)
        }
      }

      // Î∂ÑÏÑù ÏÑ§Ï†ï Íµ¨ÏÑ±
      const analysisConfig: AnalysisConfig = {
        includeTests,
        includeDocumentation: includeDocs,
        includeNodeModules,
        maxDepth,
        excludePatterns: [
          '**/node_modules/**',
          '**/dist/**',
          '**/build/**',
          '**/.git/**'
        ],
        testConfig: {
          detectTestFrameworks: true,
          analyzeMocks: true,
          calculateCoverage: true
        },
        codeConfig: {
          resolveTypeImports: true,
          analyzeUsage: true,
          detectCircularDeps: true
        },
        docConfig: {
          validateLinks: true,
          extractMetadata: true,
          analyzeStructure: true
        }
      }

      // Ï†ÄÏû• ÏòµÏÖò Íµ¨ÏÑ±
      const storageOptions: StorageOptions = {
        format: format as StorageOptions['format'],
        compression,
        incremental,
        includeMetadata: true,
        includeSourceCode: verbose
      }

      // ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ Ï∞æÍ∏∞
      const projectRoot = yield* Effect.tryPromise(async () => {
        return findProjectRoot(filePath)
      })

      if (verbose) {
        yield* Console.log(`üè† ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏: ${projectRoot}`)
      }

      // ÌÜµÌï© Î∂ÑÏÑùÍ∏∞ ÏÉùÏÑ±
      const analyzer = new UnifiedDependencyAnalyzer(projectRoot)

      // Î∂ÑÏÑù Ïã§Ìñâ
      yield* Console.log(`üöÄ ÏùòÏ°¥ÏÑ± Î∂ÑÎ•ò Î∂ÑÏÑù ÏãúÏûë...`)
      const startTime = Date.now()

      const result = yield* Effect.tryPromise(async () => {
        return await analyzer.analyzeProject(files)
      })

      const duration = Date.now() - startTime

      // Î∂ÑÏÑù Í≤∞Í≥º Ï∂úÎ†•
      yield* outputAnalysisResults(result, verbose)

      // Ï∞∏Ï°∞ Í¥ÄÍ≥Ñ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
      yield* Console.log(`\nüîó Ï∞∏Ï°∞ Í¥ÄÍ≥Ñ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Ï§ë...`)
      const metadataExtractor = new MetadataExtractor(projectRoot)
      const referenceData = yield* Effect.tryPromise(async () => {
        return metadataExtractor.extractMetadata(result)
      })

      // Ï∞∏Ï°∞ Í¥ÄÍ≥Ñ ÏöîÏïΩ Ï∂úÎ†•
      yield* outputReferenceMetadata(referenceData, verbose)

      // Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÑ§Ï†ï
      const outputDirectory = Option.getOrElse(outputDir, () => path.join(projectRoot, '.deps-analysis'))
      const baseFileName = Option.getOrElse(outputName, () => 'analysis-result')

      // ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
      yield* Effect.tryPromise(async () => {
        await fs.promises.mkdir(outputDirectory, { recursive: true })
      })

      yield* Effect.tryPromise(async () => {
        await analyzer.save(result, {
          ...storageOptions,
          format: format as StorageOptions['format']
        })

        // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î≥ÑÎèÑ Ï†ÄÏû•
        if (outputMetadata) {
          await saveReferenceMetadata(referenceData, outputDirectory, format, baseFileName)
        }
      })

      // Ï∂îÍ∞Ä Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
      if (generateReport) {
        yield* Console.log(`üìÑ Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± Ï§ë...`)
        yield* Effect.tryPromise(async () => {
          await generateAnalysisReport(referenceData, result, outputDirectory, baseFileName)
        })
      }

      if (generateVisualization) {
        yield* Console.log(`üìä ÏãúÍ∞ÅÌôî Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ± Ï§ë...`)
        yield* Effect.tryPromise(async () => {
          await generateVisualizationFiles(referenceData, result, outputDirectory, baseFileName)
        })
      }

      yield* Console.log(`‚úÖ Î∂ÑÏÑù ÏôÑÎ£å! (${duration}ms)`)
      yield* Console.log(`üíæ Í≤∞Í≥º Ï†ÄÏû•Îê®: ${outputDirectory}`)

      // ÌÉÄÏûÖÎ≥Ñ ÏöîÏïΩ Ï∂úÎ†•
      yield* outputTypeSummary(result, nodeType as NodeType | 'all')
    })
  )
)

// ÌååÏùº ÏàòÏßë Ìï®Ïàò
async function collectFiles(
  dirPath: string,
  options: {
    includeTests: boolean
    includeDocs: boolean
    includeNodeModules: boolean
    maxDepth: number
    nodeType: NodeType | 'all'
    excludePatterns: string
    includePatterns: string
    minFileSize: number
    maxFileSize: number
    confidenceThreshold: number
  }
): Promise<string[]> {
  const files: string[] = []

  const extensions = ['.ts', '.tsx', '.js', '.jsx', '.vue', '.svelte']
  if (options.includeDocs) {
    extensions.push('.md', '.markdown', '.rst', '.txt')
  }

  // Ìå®ÌÑ¥ Ï≤òÎ¶¨
  const excludePatterns = options.excludePatterns ?
    options.excludePatterns.split(',').map(p => p.trim()).filter(Boolean) : []
  const includePatterns = options.includePatterns ?
    options.includePatterns.split(',').map(p => p.trim()).filter(Boolean) : []

  const shouldExcludeFile = (filePath: string): boolean => {
    if (excludePatterns.length === 0) return false
    return excludePatterns.some(pattern => {
      const regex = new RegExp(pattern.replace(/\*/g, '.*').replace(/\?/g, '.'))
      return regex.test(filePath)
    })
  }

  const shouldIncludeFile = (filePath: string): boolean => {
    if (includePatterns.length === 0) return true
    return includePatterns.some(pattern => {
      const regex = new RegExp(pattern.replace(/\*/g, '.*').replace(/\?/g, '.'))
      return regex.test(filePath)
    })
  }

  const walk = async (currentPath: string, depth: number) => {
    if (depth > options.maxDepth) return

    try {
      const entries = await fs.promises.readdir(currentPath, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(currentPath, entry.name)

        // Ï†úÏô∏ Ìå®ÌÑ¥ Ï≤¥ÌÅ¨
        if (!options.includeNodeModules && entry.name === 'node_modules') continue
        if (entry.name.startsWith('.') && entry.name !== '.md') continue

        if (entry.isDirectory()) {
          await walk(fullPath, depth + 1)
        } else if (entry.isFile()) {
          const ext = path.extname(entry.name)

          if (extensions.includes(ext)) {
            // Ìå®ÌÑ¥ ÌïÑÌÑ∞ÎßÅ
            if (shouldExcludeFile(fullPath)) continue
            if (!shouldIncludeFile(fullPath)) continue

            // ÌååÏùº ÌÅ¨Í∏∞ ÌïÑÌÑ∞ÎßÅ
            try {
              const stat = await fs.promises.stat(fullPath)
              if (stat.size < options.minFileSize || stat.size > options.maxFileSize) continue
            } catch (error) {
              console.warn(`ÌååÏùº ÌÅ¨Í∏∞ ÌôïÏù∏ Ïã§Ìå®: ${fullPath}`, error)
              continue
            }

            const nodeType = getFileNodeType(fullPath)

            // ÎÖ∏Îìú ÌÉÄÏûÖ ÌïÑÌÑ∞ÎßÅ
            if (options.nodeType !== 'all' && nodeType !== options.nodeType) continue

            // ÌÖåÏä§Ìä∏ ÌååÏùº ÌïÑÌÑ∞ÎßÅ
            if (!options.includeTests && nodeType === 'test') continue

            // Î¨∏ÏÑú ÌååÏùº ÌïÑÌÑ∞ÎßÅ
            if (!options.includeDocs && nodeType === 'docs') continue

            files.push(fullPath)
          }
        }
      }
    } catch (error) {
      console.warn(`ÎîîÎ†âÌÜ†Î¶¨ ÏùΩÍ∏∞ Ïã§Ìå®: ${currentPath}`, error)
    }
  }

  await walk(dirPath, 0)
  return files
}

// ÌååÏùº ÎÖ∏Îìú ÌÉÄÏûÖ Í≤∞Ï†ï
function getFileNodeType(filePath: string): NodeType {
  const normalizedPath = filePath.toLowerCase()

  if (
    normalizedPath.includes('.test.') ||
    normalizedPath.includes('.spec.') ||
    normalizedPath.includes('/__tests__/') ||
    normalizedPath.includes('/test/') ||
    normalizedPath.includes('/tests/')
  ) {
    return 'test'
  }

  if (
    normalizedPath.endsWith('.md') ||
    normalizedPath.endsWith('.markdown') ||
    normalizedPath.endsWith('.rst') ||
    normalizedPath.endsWith('.txt')
  ) {
    return 'docs'
  }

  if (normalizedPath.includes('node_modules')) {
    return 'library'
  }

  return 'code'
}

// ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ Ï∞æÍ∏∞
function findProjectRoot(startPath: string): string {
  let currentPath = path.resolve(startPath)

  while (currentPath !== path.dirname(currentPath)) {
    const indicators = ['package.json', 'tsconfig.json', '.git']

    for (const indicator of indicators) {
      if (fs.existsSync(path.join(currentPath, indicator))) {
        return currentPath
      }
    }

    currentPath = path.dirname(currentPath)
  }

  return path.dirname(startPath)
}

// Î∂ÑÏÑù Í≤∞Í≥º Ï∂úÎ†•
const outputAnalysisResults = (result: any, verbose: boolean) =>
  Effect.gen(function*() {
    yield* Console.log(`\nüìä ÏùòÏ°¥ÏÑ± Î∂ÑÎ•ò Î∂ÑÏÑù Í≤∞Í≥º`)
    yield* Console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

    // Í∏∞Î≥∏ ÌÜµÍ≥Ñ
    yield* Console.log(`üìÅ Ï¥ù ÌååÏùº: ${result.graph.nodes.size}Í∞ú`)
    yield* Console.log(`üîó Ï¥ù ÏùòÏ°¥ÏÑ±: ${result.graph.metrics.totalDependencies}Í∞ú`)
    yield* Console.log(`‚è±Ô∏è Î∂ÑÏÑù ÏãúÍ∞Ñ: ${result.analysisMetadata.duration}ms`)

    // ÌååÏùº ÌÉÄÏûÖÎ≥Ñ ÌÜµÍ≥Ñ
    yield* Console.log(`\nüìã ÌååÏùº ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨:`)
    for (const [nodeType, count] of Object.entries(result.report.summary.fileTypes)) {
      const icon = getNodeTypeIcon(nodeType as NodeType)
      yield* Console.log(`  ${icon} ${nodeType}: ${count}Í∞ú`)
    }

    // ÏùòÏ°¥ÏÑ± ÌÉÄÏûÖÎ≥Ñ ÌÜµÍ≥Ñ
    yield* Console.log(`\nüîó ÏùòÏ°¥ÏÑ± ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨:`)
    for (const [depType, count] of Object.entries(result.report.summary.dependencyTypes)) {
      yield* Console.log(`  ‚Ä¢ ${depType}: ${count}Í∞ú`)
    }

    // ÌÅ¥Îü¨Ïä§ÌÑ∞ Ï†ïÎ≥¥
    if (result.graph.clusters.size > 0) {
      yield* Console.log(`\nüèóÔ∏è ÏΩîÎìú ÌÅ¥Îü¨Ïä§ÌÑ∞:`)
      for (const [name, cluster] of result.graph.clusters.entries()) {
        yield* Console.log(`  üì¶ ${name}: ${cluster.files.length}Í∞ú ÌååÏùº (ÏùëÏßëÎèÑ: ${Math.round(cluster.cohesion * 100)}%)`)
      }
    }

    // Í≤ΩÍ≥† Î∞è ÏúÑÌóò ÏöîÏÜå
    if (result.analysisMetadata.warnings.length > 0) {
      yield* Console.log(`\n‚ö†Ô∏è Í≤ΩÍ≥†ÏÇ¨Ìï≠:`)
      for (const warning of result.analysisMetadata.warnings.slice(0, 5)) {
        yield* Console.log(`  ‚Ä¢ ${warning}`)
      }
      if (result.analysisMetadata.warnings.length > 5) {
        yield* Console.log(`  ... Í∑∏Î¶¨Í≥† ${result.analysisMetadata.warnings.length - 5}Í∞ú Îçî`)
      }
    }

    if (verbose) {
      // ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂úÎ†•
      yield* outputDetailedAnalysis(result)
    }
  })

// ÌÉÄÏûÖÎ≥Ñ ÏöîÏïΩ Ï∂úÎ†•
const outputTypeSummary = (result: any, filterType: NodeType | 'all') =>
  Effect.gen(function*() {
    yield* Console.log(`\nüéØ ${filterType === 'all' ? 'Ï†ÑÏ≤¥' : filterType} ÎÖ∏Îìú ÌÉÄÏûÖ ÏÉÅÏÑ∏ Î∂ÑÏÑù`)
    yield* Console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

    for (const [nodeType, nodes] of result.nodesByType.entries()) {
      if (filterType !== 'all' && nodeType !== filterType) continue

      const icon = getNodeTypeIcon(nodeType)
      yield* Console.log(`\n${icon} ${nodeType.toUpperCase()} ÌååÏùºÎì§ (${nodes.length}Í∞ú):`)

      // ÏÉÅÏúÑ ÏùòÏ°¥ÏÑ±Ïù¥ ÎßéÏùÄ ÌååÏùºÎì§
      const sortedByDeps = nodes
        .sort((a: any, b: any) => b.analysis.totalDependencies - a.analysis.totalDependencies)
        .slice(0, 5)

      yield* Console.log(`  üìä ÏùòÏ°¥ÏÑ±Ïù¥ ÎßéÏùÄ ÌååÏùºÎì§:`)
      for (const node of sortedByDeps) {
        yield* Console.log(`    ‚Ä¢ ${node.relativePath}: ${node.analysis.totalDependencies}Í∞ú`)
      }

      // ÌÉÄÏûÖÎ≥Ñ ÌäπÌôî Ï†ïÎ≥¥
      yield* outputNodeTypeSpecificInfo(nodeType, nodes)
    }
  })

// ÎÖ∏Îìú ÌÉÄÏûÖÎ≥Ñ ÌäπÌôî Ï†ïÎ≥¥ Ï∂úÎ†•
const outputNodeTypeSpecificInfo = (nodeType: NodeType, nodes: any[]) =>
  Effect.gen(function*() {
    switch (nodeType) {
      case 'test':
        const totalTargets = nodes.reduce((sum, node) => sum + node.dependencies.filter((d: any) => d.type === 'test-target').length, 0)
        yield* Console.log(`    üéØ ÌÖåÏä§Ìä∏ ÎåÄÏÉÅ: ${totalTargets}Í∞ú`)
        break

      case 'code':
        const circularDeps = nodes.filter(node => node.analysis.cyclicDependencies.length > 0).length
        yield* Console.log(`    üîÑ ÏàúÌôò ÏùòÏ°¥ÏÑ±: ${circularDeps}Í∞ú ÌååÏùº`)
        break

      case 'docs':
        const brokenLinks = nodes.reduce((sum, node) => sum + node.dependencies.filter((d: any) => !d.exists).length, 0)
        yield* Console.log(`    üîó Íπ®ÏßÑ ÎßÅÌÅ¨: ${brokenLinks}Í∞ú`)
        break

      case 'library':
        yield* Console.log(`    üì¶ Ïô∏Î∂Ä ÎùºÏù¥Î∏åÎü¨Î¶¨`)
        break
    }
  })

// ÏÉÅÏÑ∏ Î∂ÑÏÑù Ï∂úÎ†•
const outputDetailedAnalysis = (result: any) =>
  Effect.gen(function*() {
    yield* Console.log(`\nüîç ÏÉÅÏÑ∏ Î∂ÑÏÑù Í≤∞Í≥º`)
    yield* Console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

    // ÌÖåÏä§Ìä∏ Ïª§Î≤ÑÎ¶¨ÏßÄ
    if (result.report.testAnalysis) {
      const coverage = Math.round(result.report.testAnalysis.testCoverage * 100)
      yield* Console.log(`üß™ ÌÖåÏä§Ìä∏ Ïª§Î≤ÑÎ¶¨ÏßÄ: ${coverage}%`)

      if (result.report.testAnalysis.uncoveredFiles.length > 0) {
        yield* Console.log(`  ÌÖåÏä§Ìä∏ÎêòÏßÄ ÏïäÏùÄ ÌååÏùºÎì§:`)
        for (const file of result.report.testAnalysis.uncoveredFiles.slice(0, 3)) {
          yield* Console.log(`    ‚Ä¢ ${file}`)
        }
      }
    }

    // ÏïÑÌÇ§ÌÖçÏ≤ò Î©îÌä∏Î¶≠
    yield* Console.log(`\nüèóÔ∏è ÏïÑÌÇ§ÌÖçÏ≤ò Î©îÌä∏Î¶≠:`)
    yield* Console.log(`  ‚Ä¢ ÌèâÍ∑† ÏùòÏ°¥ÏÑ±: ${Math.round(result.graph.metrics.averageDependenciesPerFile)}Í∞ú/ÌååÏùº`)
    yield* Console.log(`  ‚Ä¢ ÏµúÎåÄ ÍπäÏù¥: ${result.graph.metrics.maxDepth}`)
    yield* Console.log(`  ‚Ä¢ Í≥†Î¶ΩÎêú ÌååÏùº: ${result.graph.metrics.isolatedFileCount}Í∞ú`)

    // Ï∂îÏ≤úÏÇ¨Ìï≠
    if (result.report.recommendations.length > 0) {
      yield* Console.log(`\nüí° Ï∂îÏ≤úÏÇ¨Ìï≠:`)
      for (const rec of result.report.recommendations.slice(0, 3)) {
        yield* Console.log(`  ${getPriorityIcon(rec.priority)} ${rec.description}`)
      }
    }
  })

// Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
function getNodeTypeIcon(nodeType: NodeType): string {
  switch (nodeType) {
    case 'test': return 'üß™'
    case 'code': return 'üìÑ'
    case 'docs': return 'üìù'
    case 'library': return 'üì¶'
    default: return 'üìÅ'
  }
}

function getPriorityIcon(priority: string): string {
  switch (priority) {
    case 'high': return 'üî¥'
    case 'medium': return 'üü°'
    case 'low': return 'üü¢'
    default: return '‚ö™'
  }
}

// Ï∞∏Ï°∞ Í¥ÄÍ≥Ñ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂úÎ†•
const outputReferenceMetadata = (referenceData: any, verbose: boolean) =>
  Effect.gen(function*() {
    yield* Console.log(`\nüîó Ï∞∏Ï°∞ Í¥ÄÍ≥Ñ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞`)
    yield* Console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`)

    // Í∏∞Î≥∏ ÌÜµÍ≥Ñ
    yield* Console.log(`üìä Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÌÜµÍ≥Ñ:`)
    yield* Console.log(`  üìÅ Ï¥ù ÌååÏùº: ${referenceData.files.length}Í∞ú`)
    yield* Console.log(`  üîó Ï∞∏Ï°∞ Í¥ÄÍ≥Ñ: ${referenceData.referenceGraph.edges.length}Í∞ú`)
    yield* Console.log(`  üìà ÌèâÍ∑† ÏùòÏ°¥ÏÑ±: ${referenceData.statistics.averageDependenciesPerFile.toFixed(1)}Í∞ú/ÌååÏùº`)
    yield* Console.log(`  ‚ö†Ô∏è Í≥†Î¶ΩÎêú ÌååÏùº: ${referenceData.statistics.orphanedFiles}Í∞ú`)

    // ÌååÏùº ÌÉÄÏûÖÎ≥Ñ ÌÜµÍ≥Ñ
    yield* Console.log(`\nüìã ÌååÏùº ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨:`)
    for (const [fileType, count] of Object.entries(referenceData.statistics.filesByType)) {
      const icon = getFileTypeIcon(fileType)
      yield* Console.log(`  ${icon} ${fileType}: ${count}Í∞ú`)
    }

    // ÏùòÏ°¥ÏÑ± Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÌÜµÍ≥Ñ
    yield* Console.log(`\nüè∑Ô∏è ÏùòÏ°¥ÏÑ± Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î∂ÑÌè¨:`)
    for (const [category, count] of Object.entries(referenceData.statistics.dependenciesByCategory)) {
      yield* Console.log(`  ‚Ä¢ ${category}: ${count}Í∞ú`)
    }

    if (verbose) {
      // ÏÉÅÏÑ∏ ÌååÏùº Ï†ïÎ≥¥
      yield* Console.log(`\nüìÑ ÌååÏùºÎ≥Ñ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ (ÏÉÅÏúÑ 5Í∞ú):`)
      const topFiles = referenceData.files
        .sort((a: any, b: any) => {
          const aDeps = a.dependencies.internal.length + a.dependencies.external.length + a.dependencies.builtin.length
          const bDeps = b.dependencies.internal.length + b.dependencies.external.length + b.dependencies.builtin.length
          return bDeps - aDeps
        })
        .slice(0, 5)

      for (const file of topFiles) {
        const totalDeps = file.dependencies.internal.length + file.dependencies.external.length + file.dependencies.builtin.length
        yield* Console.log(`  üìÅ ${file.relativePath}`)
        yield* Console.log(`    ID: ${file.fileId}`)
        yield* Console.log(`    ÌÉÄÏûÖ: ${file.fileType}`)
        yield* Console.log(`    ÏùòÏ°¥ÏÑ±: ${totalDeps}Í∞ú (ÎÇ¥Î∂Ä: ${file.dependencies.internal.length}, Ïô∏Î∂Ä: ${file.dependencies.external.length})`)
        yield* Console.log(`    Ï∞∏Ï°∞ÎãπÌï®: ${file.dependents.length}Í∞ú ÌååÏùº`)
      }

      // ÏàúÌôò ÏùòÏ°¥ÏÑ± Ï≤¥ÌÅ¨ Í≤∞Í≥º
      if (referenceData.statistics.circularDependencies > 0) {
        yield* Console.log(`\nüîÑ ÏàúÌôò ÏùòÏ°¥ÏÑ± Í∞êÏßÄ: ${referenceData.statistics.circularDependencies}Í∞ú`)
      }
    }
  })

// Ï∞∏Ï°∞ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
async function saveReferenceMetadata(referenceData: any, outputDir: string, format: string, baseFileName: string = 'reference-metadata'): Promise<void> {
  const fileName = `${baseFileName}-metadata.${format === 'json' ? 'json' : 'json'}`
  const filePath = path.join(outputDir, fileName)

  // Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
  await fs.promises.mkdir(outputDir, { recursive: true })

  if (format === 'json') {
    await fs.promises.writeFile(filePath, JSON.stringify(referenceData, null, 2), 'utf-8')
  } else {
    // Îã§Î•∏ ÌòïÏãùÎèÑ JSONÏúºÎ°ú Ï†ÄÏû• (Ìñ•ÌõÑ ÌôïÏû• Í∞ÄÎä•)
    await fs.promises.writeFile(filePath, JSON.stringify(referenceData, null, 2), 'utf-8')
  }

  console.log(`üîó Ï∞∏Ï°∞ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû•Îê®: ${filePath}`)
}

// Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
async function generateAnalysisReport(referenceData: any, analysisResult: any, outputDir: string, baseFileName: string): Promise<void> {
  const reportPath = path.join(outputDir, `${baseFileName}-report.md`)

  const report = `# ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏

## üìä Î∂ÑÏÑù Í∞úÏöî
- **Î∂ÑÏÑù ÏùºÏãú**: ${referenceData.project.analyzedAt}
- **ÌîÑÎ°úÏ†ùÌä∏**: ${referenceData.project.name}
- **Î£®Ìä∏ Í≤ΩÎ°ú**: ${referenceData.project.root}

## üìà ÌÜµÍ≥Ñ Ï†ïÎ≥¥
- **Ï¥ù ÌååÏùº**: ${referenceData.statistics.totalFiles}Í∞ú
- **Ï¥ù ÏùòÏ°¥ÏÑ±**: ${referenceData.statistics.totalDependencies}Í∞ú
- **ÌèâÍ∑† ÏùòÏ°¥ÏÑ±**: ${referenceData.statistics.averageDependenciesPerFile.toFixed(1)}Í∞ú/ÌååÏùº
- **Í≥†Î¶ΩÎêú ÌååÏùº**: ${referenceData.statistics.orphanedFiles}Í∞ú

## üèóÔ∏è ÌååÏùº ÌÉÄÏûÖÎ≥Ñ Î∂ÑÌè¨
${Object.entries(referenceData.statistics.filesByType).map(([type, count]) =>
  `- **${type}**: ${count}Í∞ú`
).join('\n')}

## üîó ÏùòÏ°¥ÏÑ± Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î∂ÑÌè¨
${Object.entries(referenceData.statistics.dependenciesByCategory).map(([category, count]) =>
  `- **${category}**: ${count}Í∞ú`
).join('\n')}

## üìÑ ÌååÏùºÎ≥Ñ ÏÉÅÏÑ∏ Ï†ïÎ≥¥

${referenceData.files.slice(0, 10).map((file: any) => {
  const totalDeps = file.dependencies.internal.length + file.dependencies.external.length + file.dependencies.builtin.length
  return `### ${file.relativePath}
- **ÌååÏùº ID**: ${file.fileId}
- **ÌÉÄÏûÖ**: ${file.fileType}
- **Ïñ∏Ïñ¥**: ${file.language}
- **ÌÅ¨Í∏∞**: ${file.size} bytes
- **Î≥µÏû°ÎèÑ**: ${file.complexity}
- **ÏùòÏ°¥ÏÑ±**: ${totalDeps}Í∞ú
- **Ï∞∏Ï°∞ÎãπÌï®**: ${file.dependents.length}Í∞ú ÌååÏùº`
}).join('\n\n')}

${referenceData.files.length > 10 ? `\n... Í∑∏Î¶¨Í≥† ${referenceData.files.length - 10}Í∞ú ÌååÏùº Îçî` : ''}

---
*Ïù¥ Î¶¨Ìè¨Ìä∏Îäî deps-cli ÎèÑÍµ¨Î°ú ÏûêÎèô ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.*
`

  await fs.promises.writeFile(reportPath, report, 'utf-8')
  console.log(`üìÑ Î∂ÑÏÑù Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±Îê®: ${reportPath}`)
}

// ÏãúÍ∞ÅÌôî ÌååÏùº ÏÉùÏÑ±
async function generateVisualizationFiles(referenceData: any, analysisResult: any, outputDir: string, baseFileName: string): Promise<void> {
  // Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±
  const mermaidPath = path.join(outputDir, `${baseFileName}-diagram.mmd`)

  const topFiles = referenceData.files
    .sort((a: any, b: any) => {
      const aTotalDeps = a.dependencies.internal.length + a.dependencies.external.length
      const bTotalDeps = b.dependencies.internal.length + b.dependencies.external.length
      return bTotalDeps - aTotalDeps
    })
    .slice(0, 15)

  const mermaidContent = `graph TD
    %% ÏÉÅÏúÑ ÏùòÏ°¥ÏÑ± ÌååÏùºÎì§
${topFiles.map((file: any) => {
  const shortName = file.relativePath.split('/').pop()?.replace(/\.\w+$/, '') || 'unknown'
  const nodeId = file.fileId.replace(/[^a-zA-Z0-9]/g, '_')
  const totalDeps = file.dependencies.internal.length + file.dependencies.external.length
  return `    ${nodeId}["${shortName}<br/>deps: ${totalDeps}"]`
}).join('\n')}

    %% ÎÇ¥Î∂Ä ÏùòÏ°¥ÏÑ± Ïó∞Í≤∞
${topFiles.flatMap((file: any) =>
  file.dependencies.internal.slice(0, 3).map((dep: any) => {
    const fromId = file.fileId.replace(/[^a-zA-Z0-9]/g, '_')
    const toName = dep.source.split('/').pop()?.replace(/\.\w+$/, '').replace(/[^a-zA-Z0-9]/g, '_') || 'unknown'
    return `    ${fromId} --> ${toName}`
  })
).join('\n')}

    %% Ïä§ÌÉÄÏùº
    classDef codeFile fill:#e1f5fe
    classDef testFile fill:#f3e5f5
    classDef docsFile fill:#e8f5e8
`

  await fs.promises.writeFile(mermaidPath, mermaidContent, 'utf-8')
  console.log(`üìä Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû® ÏÉùÏÑ±Îê®: ${mermaidPath}`)

  // DOT ÌååÏùº ÏÉùÏÑ± (GraphvizÏö©)
  const dotPath = path.join(outputDir, `${baseFileName}-graph.dot`)
  const dotContent = `digraph Dependencies {
    rankdir=TB;
    node [shape=box, style=filled];

${topFiles.map((file: any) => {
  const nodeId = file.fileId.replace(/[^a-zA-Z0-9]/g, '_')
  const shortName = file.relativePath.split('/').pop()?.replace(/\.\w+$/, '') || 'unknown'
  const color = file.fileType === 'test' ? 'lightblue' : file.fileType === 'docs' ? 'lightgreen' : 'lightgray'
  return `    ${nodeId} [label="${shortName}", fillcolor="${color}"];`
}).join('\n')}

${topFiles.flatMap((file: any) =>
  file.dependencies.internal.slice(0, 3).map((dep: any) => {
    const fromId = file.fileId.replace(/[^a-zA-Z0-9]/g, '_')
    const toName = dep.source.split('/').pop()?.replace(/\.\w+$/, '').replace(/[^a-zA-Z0-9]/g, '_') || 'unknown'
    return `    ${fromId} -> ${toName};`
  })
).join('\n')}
}`

  await fs.promises.writeFile(dotPath, dotContent, 'utf-8')
  console.log(`üìä DOT Í∑∏ÎûòÌîÑ ÏÉùÏÑ±Îê®: ${dotPath}`)
}

// ÌååÏùº ÌÉÄÏûÖ ÏïÑÏù¥ÏΩò
function getFileTypeIcon(fileType: string): string {
  switch (fileType) {
    case 'code': return 'üìÑ'
    case 'test': return 'üß™'
    case 'docs': return 'üìù'
    default: return 'üìÅ'
  }
}